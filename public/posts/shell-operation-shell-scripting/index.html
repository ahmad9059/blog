<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shell Operation in Shell Scripting | ahmad</title>
<meta name=keywords content="tech,shell,scripting"><meta name=description content="Learn Shell Expansion From Scratch and Dive Deep Into Scripting"><meta name=author content="Ahmad Hassan"><link rel=canonical href=http://localhost:1313/posts/shell-operation-shell-scripting/><link crossorigin=anonymous href=/assets/css/stylesheet.ef1cd02c59d48efda91b4f660e10dc23b7ed7780cf1fbb90fc771c1ca5fb64af.css integrity="sha256-7xzQLFnUjv2pG09mDhDcI7ftd4DPH7uQ/HccHKX7ZK8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/assets/fav.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/assets/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3C/assets/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/%3Capple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/shell-operation-shell-scripting/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Work+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400..700&display=swap" rel=stylesheet><meta property="og:url" content="http://localhost:1313/posts/shell-operation-shell-scripting/"><meta property="og:site_name" content="ahmad"><meta property="og:title" content="Shell Operation in Shell Scripting"><meta property="og:description" content="Learn Shell Expansion From Scratch and Dive Deep Into Scripting"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-30T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-30T00:00:00+00:00"><meta property="article:tag" content="Tech"><meta property="article:tag" content="Shell"><meta property="article:tag" content="Scripting"><meta property="og:image" content="http://localhost:1313/assets/opengraph.webp"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/assets/opengraph.webp"><meta name=twitter:title content="Shell Operation in Shell Scripting"><meta name=twitter:description content="Learn Shell Expansion From Scratch and Dive Deep Into Scripting"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Shell Operation in Shell Scripting","item":"http://localhost:1313/posts/shell-operation-shell-scripting/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shell Operation in Shell Scripting","name":"Shell Operation in Shell Scripting","description":"Learn Shell Expansion From Scratch and Dive Deep Into Scripting","keywords":["tech","shell","scripting"],"articleBody":"Shell Operation in Bash The shell (e.g., bash) follows a multi-step process to interpret and execute commands. Each command goes through reading, breaking down, expanding, redirecting, and finally execution. Steps of Command Processing Read Input From terminal (interactive use) or file/script. Reads line by line. Tokenization (Lexical Analysis) Breaks input into words and operators. Follows specific syntax rules. Alias expansion happens at this stage. Parsing / Command Identification Tokens are recognized as: Simple commands (like ls -l) Compound commands (like if, for, pipelines, etc.) Shell Expansions (performed in order): Brace expansion → {a,b,c} → expands to a b c Tilde expansion → ~ → expands to home directory Parameter \u0026 variable expansion → $VAR Command substitution → `command` or $(command) Arithmetic expansion → $((2+3)) → 5 Process substitution → \u003c(command) or \u003e(command) Word splitting → breaks expanded words into fields Filename expansion (globbing) → *.txt → matches files Quote Removal Removes \" ' and ` while preserving meaning. Redirections Handles input/output redirection, e.g. \u003e \u003e\u003e \u003c 2\u003e\u00261. Execution The command is executed. If required, the shell waits for the command to finish. Exit status ($?) is collected. Key Points Tokenization is the first transformation stage. Expansions are ordered; each depends on the result of the previous. Redirection happens before execution. Exit status is important for scripting (conditional logic). Shell Tokenization Definition: The process of breaking input into tokens (smallest meaningful units). A token = sequence of characters treated as a single unit by the shell. How Tokenization Works Input Source From terminal or a file (script). Meta Characters Special unquoted characters that separate words. List of meta characters: Space ( ) Tab (\\t) Newline (\\n) | \u0026 ; ( ) \u003c \u003e Types of Tokens Words: tokens without unquoted meta characters. Operators: tokens containing at least one unquoted meta character. Note: If quoted, they lose their special meaning.\nOperators Control Operators → Perform control functions. Examples: ; \u0026 \u0026\u0026 || | |\u0026 ( ) \\n Redirection Operators → Redirect input/output. Examples: \u003e \u003e\u003e \u003c \u003c\u003c \u003c\u003c\u003c \u003e\u0026 \u003c\u0026 \u003e| ⚠️ Operators matter only if unquoted.\nAlias Expansion Aliases are expanded at this step, during tokenization. Example Walkthrough Command:\nls $Home \u003e Home.txt Identify meta characters Only spaces ( ) here. Split into tokens (4 tokens): ls $Home \u003e Home.txt Classify tokens: Words → ls, $Home, Home.txt Operator → \u003e (redirection) Hidden Control Operator: Newline (\\n) at the end of the command. Key Points to Remember $ is not a meta character → $Home counts as a word. Redirection operators (\u003e, \u003c) do not split commands, but control operators (;, \u0026\u0026, newline) do. Tokenization always happens before parsing and expansions. Shell Command Identification After Tokenization Shell now classifies tokens into simple or compound commands. Simple Commands Definition: Sequence of words separated by spaces, terminated by newline or a control operator. Structure: First word → command name. Remaining words → arguments. Examples: touch a.txt b.txt c.txt touch = command name a.txt b.txt c.txt = arguments Terminated by invisible newline. ⚠️ Important Notes If multiple commands are written without control operators, shell may treat them as one simple command. touch a.txt b.txt ls → Interpreted as touch with args a.txt b.txt ls (not two commands).\nUse a control operator like ; to separate them: touch a.txt b.txt ; ls → Now touch and ls are two simple commands.\nCompound Commands Definition: Commands that start and end with reserved words (bash keywords).\nReserved words examples:\nif … fi while … done for … do … done case … esac Check reserved word:\ntype if # reserved word type elif # reserved word type ls # normal command Features: Can span multiple lines. Contain both simple and compound commands inside. Used for programming constructs: conditions, loops, iterations. Example: if [ -f /etc/passwd ]; then tail -n 3 /etc/passwd fi if starts compound command. fi ends it. Inside: a test + a simple command (tail). Recap After tokenization → shell does command identification. Simple command = list of words, first word = command name, rest = arguments, terminated by newline/control operator. Compound command = starts \u0026 ends with reserved words, represents programming constructs (if, while, for, etc.). Next stage after identification = Shell Expansions. Shell Expansions Expansion happens after tokenization and command identification. Definition: Expansion is the procedure of replacing a reference with its actual value. Example: echo $HOME $HOME → expanded into /home/ahmad (actual value). Types of Expansions (in order) Brace Expansion { } Generates arbitrary strings. Example: echo file{1..3} # file1 file2 file3 Tilde Expansion ~ Expands to home directories. Example: echo ~ # /home/ahmad Parameter and Variable Expansion $VAR Expands variables, parameters, special vars. Example: echo $USER Command Substitution $( ) or ` ` Runs a command and replaces it with the output. Example: echo \"Today is $(date)\" Arithmetic Expansion $(( )) Evaluates arithmetic expressions. Example: echo $((2 + 3)) # 5 Process Substitution \u003c( ) , \u003e( ) Treats command output/input like a file. Example: diff \u003c(ls dir1) \u003c(ls dir2) Word Splitting Splits results of expansion into multiple words (based on $IFS). Example: VAR=\"a b c\" echo $VAR # a b c Filename Expansion (Globbing) Expands wildcard characters (*, ?, [ ]). Example: echo *.txt # lists all .txt files After Expansions Quote removal is performed. This removes quotes \" ' ` but keeps the expanded values. Recap Expansions = replace references with values. There are 8 types, executed in a strict order. Final step after all expansions = quote removal. Quote Removal in Bash Quote removal is performed after shell expansions.\nPurpose: remove the quoting characters that were only used to control interpretation.\nAll unquoted occurrences of:\nBackslash (\\) Single quotes (') Double quotes (\") These are removed if they did not result from an expansion.\nWhy are quotes/backslashes removed? Quotes/backslashes temporarily remove the special meaning of characters. Once the shell has interpreted them, they are no longer needed and are removed. Examples Prevent variable expansion with backslash: echo \\$USER Output:\n$USER The backslash was removed during quote removal. Printing quotes literally: echo 'single quotes' \"Linux in double quotes\" Single quotes are removed. Double quotes remain if they were quoted. Variable containing backslashes: dir=\"C:\\Windows\\System\" echo $dir Backslashes remain. Reason: they came from variable expansion, not from quoting. Key Rule Only unquoted backslashes, single quotes, and double quotes are removed, and only if they are not generated by an expansion. Shell Redirections Command Processing Context After quote removal, the last step in command line processing is redirections. Redirections control where input comes from and where output goes. Standard Data Streams Every shell command has three default streams, identified by numbers (file descriptors):\n0 → stdin (Standard Input)\nInput to the program (keyboard by default). 1 → stdout (Standard Output) 2 → stderr (Standard Error)\nError messages (screen by default). These numbers (0, 1, 2) are file descriptors opened each time a command runs.\nStandard Input Redirection (\u003c) Redirects input from a file instead of keyboard. Example: tail \u003c /etc/group cat \u003c /etc/passwd Many commands that accept a filename as an argument will read from stdin if no file is provided. Standard Output Redirection (\u003e) Redirects command output to a file instead of screen. Example: ls -l \u003e ls.txt Behavior: Creates file if it doesn’t exist. Overwrites file if it already exists. Example overwrite: ip addr \u003e ls.txt # overwrites ls.txt, removes previous ls -l output Append Redirection (\u003e\u003e) Appends output to the end of a file instead of overwriting it. Example: ls -l \u003e\u003e output.txt ip addr \u003e\u003e output.txt Behavior: Creates file if it doesn’t exist. Appends if file exists. Everything is a File in Linux Even terminals are represented as files. Check terminal device: tty # Output: /dev/pts/0 Redirect output to another terminal: ip addr \u003e /dev/pts/0 Result: Output appears in the other terminal window (like basic instant messaging). Shell Redirections (Part 2: stderr, combining, tee) File Descriptors Recap stdin (0) → standard input stdout (1) → standard output stderr (2) → standard error By default:\n\u003e = redirects stdout (fd 1). To redirect stderr, you must explicitly specify 2\u003e. Redirecting Standard Error Example command that generates error: tail -n3 /etc/shadow (normal users cannot read it)\nRedirect stderr:\ntail -n3 /etc/shadow 2\u003e error.txt No spaces between 2 and \u003e.\nCreates file if missing, overwrites if exists.\nAppend stderr:\ntail -n3 /etc/shadow 2\u003e\u003e error.txt Redirecting stdout and stderr Separately Redirect outputs to different files: tail -n2 /etc/passwd /etc/shadow \u003e output.txt 2\u003e errors.txt output.txt → normal command output. errors.txt → error messages. Redirecting stdout and stderr to Same File Redirect stdout to file, stderr to stdout: tail -n2 /etc/passwd /etc/shadow \u003e output_errors.txt 2\u003e\u00261 Explanation: 2\u003e\u00261 → redirect stderr (2) to wherever stdout (1) is going. Ampersand (\u0026) indicates stream reference, not a filename. Without \u0026, it would create a file literally called 1. Redirections with Pipes You can still combine with pipes (|). Example: extract MAC address: ifconfig | grep ether | cut -d\" \" -f10 \u003e mac.txt cut -d \" \" -f10 → splits by space, picks 10th field (MAC address). The tee Command Problem: normal redirection saves to file but hides from terminal. tee solves this by splitting output (like a plumbing T-junction). Examples:\nSave and display: ifconfig | grep ether | tee mac.txt Displays on screen + saves to mac.txt. Append mode: who | tee -a mac.txt Save to multiple files: uname -r | tee -a mac.txt kernel.txt Key Points 2\u003e → redirect stderr. \u003e defaults to stdout (1). 2\u003e\u00261 → merge stderr into stdout. Redirections work with pipes. tee → write to file(s) and screen simultaneously. Bash Redirection \u0026 Pipe Cheat Sheet Symbol / Command Meaning Example Notes \u003c Redirect stdin (input) sort \u003c file.txt Reads input from file instead of keyboard \u003e Redirect stdout (overwrite) echo hello \u003e out.txt Creates or overwrites file \u003e\u003e Redirect stdout (append) echo hi \u003e\u003e out.txt Adds to file, keeps existing content 2\u003e Redirect stderr (overwrite) ls /root 2\u003e errors.txt Errors go to file 2\u003e\u003e Redirect stderr (append) ls /root 2\u003e\u003e errors.txt Errors appended \u0026\u003e Redirect both stdout + stderr cmd \u0026\u003e all.txt Equivalent to \u003e all.txt 2\u003e\u00261 (bash-specific) 2\u003e\u00261 Redirect stderr to stdout ls /root \u003e all.txt 2\u003e\u00261 Merge both into same file ` ` (pipe) Send stdout of one cmd as stdin to another `ls `cmd 2\u003e\u00261 cmd2` Pipe stdout+stderr to next command `ls /root 2\u003e\u00261 tee Split output → screen + file `ls tee list.txt` tee -a Append mode for tee `ls tee -a list.txt` tee file1 file2 Write to multiple files `ls tee f1 f2` ⚡ Quick Notes: File Descriptors (FDs): 0 → stdin 1 → stdout 2 → stderr No spaces allowed between FD number and operator:\n✅ 2\u003e file.txt\n❌ 2 \u003e file.txt Without number: \u003e = 1\u003e (stdout). Detailed Example, Step-By-Step, How Bash Processes This Command Example command (from the video), written exactly:\nls $HOME \u003e $(date +%H_%M).txt 1) Tokenization Shell looks for unquoted meta characters (space, tab, newline, and the special symbols), to split the input into tokens.\nIn this command there are two unquoted meta characters, space and \u003e.\nImportant: the space inside $(date +%H_%M) does not count, because it is inside a command substitution, so it is treated as part of a single token.\nTokens produced:\nls $HOME \u003e $(date +%H_%M).txt Classification, after tokenization:\nWords (no unquoted meta chars): ls, $HOME, $(date +%H_%M).txt Operator (contains an unquoted meta char): \u003e Note: $ is not a meta character, so $HOME remains a single word token.\n2) Command identification The shell identifies the command type, simple or compound. This command is a simple command, because it does not start with a reserved word (if, while, for, etc). A simple command is terminated by a control operator or the invisible newline at the end of the line. Here the newline (end of line) terminates the command. \u003e is a redirection operator, not a control operator, so it stays part of the same simple command. 3) Expansions (performed in strict order) Bash runs expansions in this order, only some apply here:\nBrace expansion Tilde expansion Parameter and variable expansion Command substitution Arithmetic expansion Process substitution Word splitting Filename expansion (globbing) In our example, the relevant expansions are: Parameter expansion: $HOME → /home/student (example value) Command substitution: $(date +%H_%M) → 11_16 (example output, hour_minute) After those expansions, the command becomes: ls /home/student \u003e 11_16.txt 4) Word splitting and filename expansion, then quote removal Word splitting: bash will split expansion results into words based on $IFS (by default space, tab, newline), but only for expansions not inside double quotes. In this example, neither expansion produced spaces, so no splitting occurs. Filename expansion (globbing): only happens if there are unquoted wildcard characters (* ? [ ]) in the words, none here. Quote removal: any remaining unquoted backslashes, single quotes, double quotes that were not produced by expansions are removed. There are none here, so nothing is removed. 5) Redirections Shell inspects redirection operators and sets up file descriptors before executing the command. Here the single greater-than \u003e is present, so: stdout (fd 1) is redirected to the file 11_16.txt. If 11_16.txt does not exist, bash creates it. If it exists, bash overwrites it (use \u003e\u003e to append instead). After setting up the redirection, the command is ready to run. Execution Bash executes ls with argument /home/student. The ls output goes to the file 11_16.txt (because stdout was redirected). Bash waits for the command to finish, then collects its exit status. Quick checklist, with the most important rules illustrated by this example Meta characters only act when unquoted (spaces inside $(...) are ignored for tokenization). $ is not a meta character, it is part of words until parameter expansion runs. Command substitution is treated as a single token during tokenization. Expansions occur in a fixed order, parameter and command substitution happen before word splitting. Word splitting uses $IFS, default is space, tab, newline. If an expansion yields spaces, it can produce extra words. \u003e is a redirection operator, not a control operator, so it does not split the command into multiple commands. Redirections are applied after expansions and quote removal, before execution. \u003e creates or overwrites, \u003e\u003e appends. Invisible newline at end of input acts as the terminating control operator for a simple command. ","wordCount":"2363","inLanguage":"en","image":"http://localhost:1313/assets/opengraph.webp","datePublished":"2025-09-30T00:00:00Z","dateModified":"2025-09-30T00:00:00Z","author":{"@type":"Person","name":"Ahmad Hassan"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/shell-operation-shell-scripting/"},"publisher":{"@type":"Organization","name":"ahmad","logo":{"@type":"ImageObject","url":"http://localhost:1313/assets/fav.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="ahmad (Alt + H)">ahmad</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=About><span>About</span></a></li><li><a href=http://localhost:1313/categories/ title=Categories><span>Categories</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Shell Operation in Shell Scripting</h1><div class=post-description>Learn Shell Expansion From Scratch and Dive Deep Into Scripting</div><div class=post-meta><span title='2025-09-30 00:00:00 +0000 UTC'>September 30, 2025</span>&nbsp;·&nbsp;12 min&nbsp;·&nbsp;2363 words&nbsp;·&nbsp;Ahmad Hassan</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#shell-operation-in-bash>Shell Operation in Bash</a></li><li><a href=#steps-of-command-processing>Steps of Command Processing</a><ul><li><a href=#key-points>Key Points</a></li></ul></li><li><a href=#shell-tokenization>Shell Tokenization</a><ul><li><a href=#how-tokenization-works>How Tokenization Works</a></li><li><a href=#operators>Operators</a></li><li><a href=#alias-expansion>Alias Expansion</a></li><li><a href=#example-walkthrough>Example Walkthrough</a></li><li><a href=#key-points-to-remember>Key Points to Remember</a></li></ul></li><li><a href=#shell-command-identification>Shell Command Identification</a><ul><li><a href=#after-tokenization>After Tokenization</a></li><li><a href=#simple-commands>Simple Commands</a></li><li><a href=#-important-notes>⚠️ Important Notes</a></li><li><a href=#compound-commands>Compound Commands</a></li><li><a href=#example>Example:</a></li><li><a href=#recap>Recap</a></li></ul></li><li><a href=#shell-expansions>Shell Expansions</a><ul><li><a href=#types-of-expansions-in-order>Types of Expansions (in order)</a></li><li><a href=#after-expansions>After Expansions</a></li><li><a href=#recap-1>Recap</a></li></ul></li><li><a href=#quote-removal-in-bash>Quote Removal in Bash</a><ul><li><a href=#why-are-quotesbackslashes-removed>Why are quotes/backslashes removed?</a></li><li><a href=#examples>Examples</a></li><li><a href=#key-rule>Key Rule</a></li></ul></li><li><a href=#shell-redirections>Shell Redirections</a><ul><li><a href=#command-processing-context>Command Processing Context</a></li><li><a href=#standard-data-streams>Standard Data Streams</a></li><li><a href=#standard-input-redirection->Standard Input Redirection (<code>&lt;</code>)</a></li><li><a href=#standard-output-redirection->Standard Output Redirection (<code>></code>)</a></li><li><a href=#append-redirection->Append Redirection (<code>>></code>)</a></li><li><a href=#everything-is-a-file-in-linux>Everything is a File in Linux</a></li></ul></li><li><a href=#shell-redirections-part-2-stderr-combining-tee>Shell Redirections (Part 2: stderr, combining, tee)</a><ul><li><a href=#file-descriptors-recap>File Descriptors Recap</a></li><li><a href=#redirecting-standard-error>Redirecting Standard Error</a></li><li><a href=#redirecting-stdout-and-stderr-separately>Redirecting stdout and stderr Separately</a></li><li><a href=#redirecting-stdout-and-stderr-to-same-file>Redirecting stdout and stderr to Same File</a></li><li><a href=#redirections-with-pipes>Redirections with Pipes</a></li><li><a href=#the-tee-command>The <code>tee</code> Command</a></li><li><a href=#key-points-1>Key Points</a></li></ul></li><li><a href=#bash-redirection--pipe-cheat-sheet>Bash Redirection & Pipe Cheat Sheet</a><ul><li><a href=#-quick-notes>⚡ Quick Notes:</a></li></ul></li><li><a href=#detailed-example-step-by-step-how-bash-processes-this-command>Detailed Example, Step-By-Step, How Bash Processes This Command</a><ul><li><a href=#1-tokenization>1) Tokenization</a></li><li><a href=#2-command-identification>2) Command identification</a></li><li><a href=#3-expansions-performed-in-strict-order>3) Expansions (performed in strict order)</a></li><li><a href=#4-word-splitting-and-filename-expansion-then-quote-removal>4) Word splitting and filename expansion, then quote removal</a></li><li><a href=#5-redirections>5) Redirections</a></li><li><a href=#execution>Execution</a></li><li><a href=#quick-checklist-with-the-most-important-rules-illustrated-by-this-example>Quick checklist, with the most important rules illustrated by this example</a></li></ul></li></ul></nav></div></details></div><div class=post-content><h2 id=shell-operation-in-bash>Shell Operation in Bash<a hidden class=anchor aria-hidden=true href=#shell-operation-in-bash>#</a></h2><hr><ul><li>The shell (e.g., <strong>bash</strong>) follows a <strong>multi-step process</strong> to interpret and execute commands.</li><li>Each command goes through reading, breaking down, expanding, redirecting, and finally execution.</li></ul><h2 id=steps-of-command-processing>Steps of Command Processing<a hidden class=anchor aria-hidden=true href=#steps-of-command-processing>#</a></h2><ol><li><strong>Read Input</strong><ul><li>From <strong>terminal</strong> (interactive use) or <strong>file/script</strong>.</li><li>Reads line by line.</li></ul></li><li><strong>Tokenization (Lexical Analysis)</strong><ul><li>Breaks input into <strong>words and operators</strong>.</li><li>Follows specific <strong>syntax rules</strong>.</li><li><strong>Alias expansion</strong> happens at this stage.</li></ul></li><li><strong>Parsing / Command Identification</strong><ul><li>Tokens are recognized as:</li><li><strong>Simple commands</strong> (like <code>ls -l</code>)</li><li><strong>Compound commands</strong> (like <code>if</code>, <code>for</code>, pipelines, etc.)</li></ul></li><li><strong>Shell Expansions</strong> (performed in order):<ul><li><strong>Brace expansion</strong> → <code>{a,b,c}</code> → expands to <code>a b c</code></li><li><strong>Tilde expansion</strong> → <code>~</code> → expands to home directory</li><li><strong>Parameter & variable expansion</strong> → <code>$VAR</code></li><li><strong>Command substitution</strong> → <code>`command`</code> or <code>$(command)</code></li><li><strong>Arithmetic expansion</strong> → <code>$((2+3))</code> → <code>5</code></li><li><strong>Process substitution</strong> → <code>&lt;(command)</code> or <code>>(command)</code></li><li><strong>Word splitting</strong> → breaks expanded words into fields</li><li><strong>Filename expansion (globbing)</strong> → <code>*.txt</code> → matches files</li></ul></li><li><strong>Quote Removal</strong><ul><li>Removes <code>"</code> <code>'</code> and <code>`</code> while preserving meaning.</li></ul></li><li><strong>Redirections</strong><ul><li>Handles input/output redirection, e.g. <code>></code> <code>>></code> <code>&lt;</code> <code>2>&amp;1</code>.</li></ul></li><li><strong>Execution</strong><ul><li>The command is executed.</li><li>If required, the shell waits for the command to finish.</li><li>Exit status (<code>$?</code>) is collected.</li></ul></li></ol><h3 id=key-points>Key Points<a hidden class=anchor aria-hidden=true href=#key-points>#</a></h3><ul><li><strong>Tokenization</strong> is the first transformation stage.</li><li><strong>Expansions are ordered</strong>; each depends on the result of the previous.</li><li><strong>Redirection happens before execution</strong>.</li><li><strong>Exit status</strong> is important for scripting (conditional logic).</li></ul><h2 id=shell-tokenization>Shell Tokenization<a hidden class=anchor aria-hidden=true href=#shell-tokenization>#</a></h2><hr><ul><li><strong>Definition:</strong> The process of breaking input into <strong>tokens</strong> (smallest meaningful units).</li><li>A <strong>token</strong> = sequence of characters treated as a <strong>single unit</strong> by the shell.</li></ul><h3 id=how-tokenization-works>How Tokenization Works<a hidden class=anchor aria-hidden=true href=#how-tokenization-works>#</a></h3><ol><li><strong>Input Source</strong><ul><li>From terminal or a file (script).</li></ul></li><li><strong>Meta Characters</strong><ul><li>Special <strong>unquoted</strong> characters that separate words.</li><li><strong>List of meta characters:</strong><ul><li>Space ( )</li><li>Tab (<code>\t</code>)</li><li>Newline (<code>\n</code>)</li><li><code>| & ; ( ) &lt; ></code></li></ul></li></ul></li><li><strong>Types of Tokens</strong><ul><li><strong>Words:</strong> tokens without unquoted meta characters.</li><li><strong>Operators:</strong> tokens containing at least one unquoted meta character.</li></ul></li></ol><p><strong>Note:</strong> If quoted, they lose their special meaning.</p><h3 id=operators>Operators<a hidden class=anchor aria-hidden=true href=#operators>#</a></h3><ol><li><strong>Control Operators</strong> → Perform control functions.<ul><li>Examples: <code>; & && || | |& ( ) \n</code></li></ul></li><li><strong>Redirection Operators</strong> → Redirect input/output.<ul><li>Examples: <code>> >> &lt; &lt;&lt; &lt;&lt;&lt; >& &lt;& >|</code></li></ul></li></ol><p><img alt=|262x331 loading=lazy src=/1-Notes/Shell%20Scripting/assets/img.webp></p><p>⚠️ Operators matter <strong>only if unquoted</strong>.</p><h3 id=alias-expansion>Alias Expansion<a hidden class=anchor aria-hidden=true href=#alias-expansion>#</a></h3><ul><li>Aliases are expanded <strong>at this step</strong>, during tokenization.</li></ul><h3 id=example-walkthrough>Example Walkthrough<a hidden class=anchor aria-hidden=true href=#example-walkthrough>#</a></h3><p>Command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls <span style=color:#8be9fd;font-style:italic>$Home</span> &gt; Home.txt
</span></span></code></pre></div><ol><li><strong>Identify meta characters</strong><ul><li>Only spaces ( ) here.</li></ul></li><li><strong>Split into tokens (4 tokens):</strong><ul><li><code>ls</code></li><li><code>$Home</code></li><li><code>></code></li><li><code>Home.txt</code></li></ul></li><li><strong>Classify tokens:</strong><ul><li>Words → <code>ls</code>, <code>$Home</code>, <code>Home.txt</code></li><li>Operator → <code>></code> (redirection)</li></ul></li><li><strong>Hidden Control Operator:</strong><ul><li>Newline (<code>\n</code>) at the end of the command.</li></ul></li></ol><h3 id=key-points-to-remember>Key Points to Remember<a hidden class=anchor aria-hidden=true href=#key-points-to-remember>#</a></h3><ul><li><code>$</code> is <strong>not</strong> a meta character → <code>$Home</code> counts as a word.</li><li>Redirection operators (<code>></code>, <code>&lt;</code>) do not split commands, but <strong>control operators</strong> (<code>;</code>, <code>&&</code>, newline) do.</li><li><strong>Tokenization always happens before parsing and expansions.</strong></li></ul><h2 id=shell-command-identification>Shell Command Identification<a hidden class=anchor aria-hidden=true href=#shell-command-identification>#</a></h2><h3 id=after-tokenization>After Tokenization<a hidden class=anchor aria-hidden=true href=#after-tokenization>#</a></h3><ul><li>Shell now <strong>classifies tokens</strong> into <strong>simple</strong> or <strong>compound commands</strong>.</li></ul><h3 id=simple-commands>Simple Commands<a hidden class=anchor aria-hidden=true href=#simple-commands>#</a></h3><ul><li><strong>Definition:</strong> Sequence of words separated by spaces, terminated by <strong>newline</strong> or a <strong>control operator</strong>.</li><li><strong>Structure:</strong><ul><li>First word → <strong>command name</strong>.</li><li>Remaining words → <strong>arguments</strong>.</li></ul></li><li><strong>Examples:</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch a.txt b.txt c.txt
</span></span></code></pre></div><ul><li><code>touch</code> = command name</li><li><code>a.txt b.txt c.txt</code> = arguments</li><li>Terminated by invisible newline.</li></ul><h3 id=-important-notes>⚠️ Important Notes<a hidden class=anchor aria-hidden=true href=#-important-notes>#</a></h3><ul><li>If multiple commands are written without control operators, shell may treat them as <strong>one simple command</strong>.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch a.txt b.txt ls
</span></span></code></pre></div><p>→ Interpreted as <code>touch</code> with args <code>a.txt b.txt ls</code> (not two commands).</p><ul><li>Use a <strong>control operator</strong> like <code>;</code> to separate them:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>touch a.txt b.txt ; ls
</span></span></code></pre></div><p>→ Now <code>touch</code> and <code>ls</code> are <strong>two simple commands</strong>.</p><h3 id=compound-commands>Compound Commands<a hidden class=anchor aria-hidden=true href=#compound-commands>#</a></h3><ul><li><p><strong>Definition:</strong> Commands that start <strong>and end</strong> with <strong>reserved words</strong> (bash keywords).</p></li><li><p><strong>Reserved words examples:</strong></p><ul><li><code>if … fi</code></li><li><code>while … done</code></li><li><code>for … do … done</code></li><li><code>case … esac</code></li></ul></li><li><p><strong>Check reserved word:</strong></p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>type</span> <span style=color:#ff79c6>if</span>      <span style=color:#6272a4># reserved word</span>
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>type</span> <span style=color:#ff79c6>elif</span>    <span style=color:#6272a4># reserved word</span>
</span></span><span style=display:flex><span>   <span style=color:#8be9fd;font-style:italic>type</span> ls      <span style=color:#6272a4># normal command</span>
</span></span></code></pre></div><ul><li><strong>Features:</strong><ul><li>Can span multiple lines.</li><li>Contain both simple and compound commands inside.</li><li>Used for <strong>programming constructs</strong>: conditions, loops, iterations.</li></ul></li></ul><h3 id=example>Example:<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#ff79c6>if</span> <span style=color:#ff79c6>[</span> -f /etc/passwd <span style=color:#ff79c6>]</span>; <span style=color:#ff79c6>then</span>
</span></span><span style=display:flex><span>    tail -n <span style=color:#bd93f9>3</span> /etc/passwd
</span></span><span style=display:flex><span><span style=color:#ff79c6>fi</span>
</span></span></code></pre></div><ul><li><code>if</code> starts compound command.</li><li><code>fi</code> ends it.</li><li>Inside: a <strong>test</strong> + a simple command (<code>tail</code>).</li></ul><h3 id=recap>Recap<a hidden class=anchor aria-hidden=true href=#recap>#</a></h3><ol><li>After tokenization → shell does <strong>command identification</strong>.</li><li><strong>Simple command</strong> = list of words, first word = command name, rest = arguments, terminated by newline/control operator.</li><li><strong>Compound command</strong> = starts & ends with reserved words, represents programming constructs (if, while, for, etc.).</li><li>Next stage after identification = <strong>Shell Expansions</strong>.</li></ol><h2 id=shell-expansions>Shell Expansions<a hidden class=anchor aria-hidden=true href=#shell-expansions>#</a></h2><hr><ul><li>Expansion happens <strong>after tokenization</strong> and <strong>command identification</strong>.</li><li><strong>Definition:</strong> Expansion is the procedure of replacing a reference with its actual value.</li><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$HOME</span>
</span></span></code></pre></div><ul><li><code>$HOME</code> → expanded into <code>/home/ahmad</code> (actual value).</li></ul><h3 id=types-of-expansions-in-order>Types of Expansions (in order)<a hidden class=anchor aria-hidden=true href=#types-of-expansions-in-order>#</a></h3><ol><li><strong>Brace Expansion <code>{ }</code></strong><ul><li>Generates arbitrary strings.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> file<span style=color:#ff79c6>{</span>1..3<span style=color:#ff79c6>}</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># file1 file2 file3</span>
</span></span></code></pre></div><ol start=2><li><strong>Tilde Expansion <code>~</code></strong><ul><li>Expands to home directories.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> ~
</span></span><span style=display:flex><span><span style=color:#6272a4># /home/ahmad</span>
</span></span></code></pre></div><ol start=3><li><strong>Parameter and Variable Expansion <code>$VAR</code></strong><ul><li>Expands variables, parameters, special vars.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$USER</span>
</span></span></code></pre></div><ol start=4><li><strong>Command Substitution <code>$( )</code> or <code>` `</code></strong><ul><li>Runs a command and replaces it with the output.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#34;Today is </span><span style=color:#ff79c6>$(</span>date<span style=color:#ff79c6>)</span><span style=color:#f1fa8c>&#34;</span>
</span></span></code></pre></div><ol start=5><li><strong>Arithmetic Expansion <code>$(( ))</code></strong><ul><li>Evaluates arithmetic expressions.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#ff79c6>$((</span><span style=color:#bd93f9>2</span> <span style=color:#ff79c6>+</span> <span style=color:#bd93f9>3</span><span style=color:#ff79c6>))</span>
</span></span><span style=display:flex><span><span style=color:#6272a4># 5</span>
</span></span></code></pre></div><ol start=6><li><strong>Process Substitution <code>&lt;( ) , >( )</code></strong><ul><li>Treats command output/input like a file.</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>diff &lt;<span style=color:#ff79c6>(</span>ls dir1<span style=color:#ff79c6>)</span> &lt;<span style=color:#ff79c6>(</span>ls dir2<span style=color:#ff79c6>)</span>
</span></span></code></pre></div><ol start=7><li><strong>Word Splitting</strong><ul><li>Splits results of expansion into multiple words (based on <code>$IFS</code>).</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>VAR</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;a b c&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$VAR</span>   <span style=color:#6272a4># a b c</span>
</span></span></code></pre></div><ol start=8><li><strong>Filename Expansion (Globbing)</strong><ul><li>Expands wildcard characters (<code>*</code>, <code>?</code>, <code>[ ]</code>).</li><li>Example:</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> *.txt
</span></span><span style=display:flex><span><span style=color:#6272a4># lists all .txt files</span>
</span></span></code></pre></div><h3 id=after-expansions>After Expansions<a hidden class=anchor aria-hidden=true href=#after-expansions>#</a></h3><ul><li><strong>Quote removal</strong> is performed.</li><li>This removes quotes <code>"</code> <code>'</code> <code>`</code> but keeps the expanded values.</li></ul><h3 id=recap-1>Recap<a hidden class=anchor aria-hidden=true href=#recap-1>#</a></h3><ul><li>Expansions = replace references with values.</li><li>There are <strong>8 types</strong>, executed in a strict order.</li><li>Final step after all expansions = <strong>quote removal</strong>.</li></ul><h2 id=quote-removal-in-bash>Quote Removal in Bash<a hidden class=anchor aria-hidden=true href=#quote-removal-in-bash>#</a></h2><hr><ul><li><p><strong>Quote removal</strong> is performed <strong>after shell expansions</strong>.</p></li><li><p>Purpose: remove the quoting characters that were only used to control interpretation.</p></li><li><p>All <strong>unquoted occurrences</strong> of:</p><ul><li>Backslash (<code>\</code>)</li><li>Single quotes (<code>'</code>)</li><li>Double quotes (<code>"</code>)</li></ul></li><li><p>These are removed <strong>if they did not result from an expansion</strong>.</p></li></ul><h3 id=why-are-quotesbackslashes-removed>Why are quotes/backslashes removed?<a hidden class=anchor aria-hidden=true href=#why-are-quotesbackslashes-removed>#</a></h3><ul><li>Quotes/backslashes temporarily remove the <strong>special meaning</strong> of characters.</li><li>Once the shell has interpreted them, they are no longer needed and are removed.</li></ul><h3 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h3><ol><li>Prevent variable expansion with backslash:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>\$</span>USER
</span></span></code></pre></div><p>Output:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>$USER</span>
</span></span></code></pre></div><ul><li>The backslash was removed during quote removal.</li></ul><ol start=2><li>Printing quotes literally:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span> <span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#f1fa8c>&#39;single quotes&#39;</span> <span style=color:#f1fa8c>&#34;Linux in double quotes&#34;</span>
</span></span></code></pre></div><ul><li>Single quotes are removed.</li><li>Double quotes remain if they were quoted.</li></ul><ol start=3><li>Variable containing backslashes:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>dir</span><span style=color:#ff79c6>=</span><span style=color:#f1fa8c>&#34;C:\Windows\System&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8be9fd;font-style:italic>echo</span> <span style=color:#8be9fd;font-style:italic>$dir</span>
</span></span></code></pre></div><ul><li>Backslashes remain.</li><li>Reason: they came from <strong>variable expansion</strong>, not from quoting.</li></ul><h3 id=key-rule>Key Rule<a hidden class=anchor aria-hidden=true href=#key-rule>#</a></h3><ul><li><strong>Only unquoted backslashes, single quotes, and double quotes</strong> are removed,</li><li>and only if they are not generated by an expansion.</li></ul><h2 id=shell-redirections>Shell Redirections<a hidden class=anchor aria-hidden=true href=#shell-redirections>#</a></h2><hr><h3 id=command-processing-context>Command Processing Context<a hidden class=anchor aria-hidden=true href=#command-processing-context>#</a></h3><ul><li>After <strong>quote removal</strong>, the <strong>last step</strong> in command line processing is <strong>redirections</strong>.</li><li>Redirections control where input comes from and where output goes.</li></ul><h3 id=standard-data-streams>Standard Data Streams<a hidden class=anchor aria-hidden=true href=#standard-data-streams>#</a></h3><p>Every shell command has <strong>three default streams</strong>, identified by numbers (file descriptors):</p><ul><li><strong>0 → stdin (Standard Input)</strong><br>Input to the program (keyboard by default).</li><li><strong>1 → stdout (Standard Output)</strong></li><li><strong>2 → stderr (Standard Error)</strong><br>Error messages (screen by default).</li></ul><p><img alt=|715x406 loading=lazy src=/1-Notes/Shell%20Scripting/assets/img-1.webp></p><blockquote><p>These numbers (0, 1, 2) are <strong>file descriptors</strong> opened each time a command runs.</p></blockquote><h3 id=standard-input-redirection->Standard Input Redirection (<code>&lt;</code>)<a hidden class=anchor aria-hidden=true href=#standard-input-redirection->#</a></h3><ul><li>Redirects input from a file instead of keyboard.</li><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail &lt; /etc/group
</span></span><span style=display:flex><span>cat &lt; /etc/passwd
</span></span></code></pre></div><ul><li>Many commands that accept a filename as an argument will read from <strong>stdin</strong> if no file is provided.</li></ul><h3 id=standard-output-redirection->Standard Output Redirection (<code>></code>)<a hidden class=anchor aria-hidden=true href=#standard-output-redirection->#</a></h3><ul><li>Redirects command output to a file instead of screen.</li><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l &gt; ls.txt
</span></span></code></pre></div><ul><li>Behavior:<ul><li>Creates file if it doesn’t exist.</li><li><strong>Overwrites</strong> file if it already exists.</li></ul></li><li>Example overwrite:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip addr &gt; ls.txt
</span></span><span style=display:flex><span><span style=color:#6272a4># overwrites ls.txt, removes previous ls -l output</span>
</span></span></code></pre></div><h3 id=append-redirection->Append Redirection (<code>>></code>)<a hidden class=anchor aria-hidden=true href=#append-redirection->#</a></h3><ul><li>Appends output to the end of a file instead of overwriting it.</li><li>Example:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls -l &gt;&gt; output.txt
</span></span><span style=display:flex><span>ip addr &gt;&gt; output.txt
</span></span></code></pre></div><ul><li>Behavior:<ul><li>Creates file if it doesn’t exist.</li><li>Appends if file exists.</li></ul></li></ul><h3 id=everything-is-a-file-in-linux>Everything is a File in Linux<a hidden class=anchor aria-hidden=true href=#everything-is-a-file-in-linux>#</a></h3><ul><li>Even terminals are represented as files.</li><li>Check terminal device:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tty
</span></span><span style=display:flex><span><span style=color:#6272a4># Output: /dev/pts/0</span>
</span></span></code></pre></div><ul><li>Redirect output to another terminal:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ip addr &gt; /dev/pts/0
</span></span></code></pre></div><ul><li>Result: Output appears in the <strong>other terminal window</strong> (like basic instant messaging).</li></ul><h2 id=shell-redirections-part-2-stderr-combining-tee>Shell Redirections (Part 2: stderr, combining, tee)<a hidden class=anchor aria-hidden=true href=#shell-redirections-part-2-stderr-combining-tee>#</a></h2><hr><h3 id=file-descriptors-recap>File Descriptors Recap<a hidden class=anchor aria-hidden=true href=#file-descriptors-recap>#</a></h3><ul><li><strong>stdin (0)</strong> → standard input</li><li><strong>stdout (1)</strong> → standard output</li><li><strong>stderr (2)</strong> → standard error</li></ul><p>By default:</p><ul><li><code>></code> = redirects <strong>stdout</strong> (fd 1).</li><li>To redirect <strong>stderr</strong>, you must <strong>explicitly specify <code>2></code></strong>.</li></ul><h3 id=redirecting-standard-error>Redirecting Standard Error<a hidden class=anchor aria-hidden=true href=#redirecting-standard-error>#</a></h3><ul><li>Example command that generates error:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -n3 /etc/shadow
</span></span></code></pre></div><ul><li><p>(normal users cannot read it)</p></li><li><p>Redirect stderr:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -n3 /etc/shadow 2&gt; error.txt
</span></span></code></pre></div><ul><li><p>No spaces between <code>2</code> and <code>></code>.</p></li><li><p>Creates file if missing, overwrites if exists.</p></li><li><p>Append stderr:</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -n3 /etc/shadow 2&gt;&gt; error.txt
</span></span></code></pre></div><h3 id=redirecting-stdout-and-stderr-separately>Redirecting stdout and stderr Separately<a hidden class=anchor aria-hidden=true href=#redirecting-stdout-and-stderr-separately>#</a></h3><ul><li>Redirect outputs to different files:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -n2 /etc/passwd /etc/shadow &gt; output.txt 2&gt; errors.txt
</span></span></code></pre></div><ul><li><code>output.txt</code> → normal command output.</li><li><code>errors.txt</code> → error messages.</li></ul><h3 id=redirecting-stdout-and-stderr-to-same-file>Redirecting stdout and stderr to Same File<a hidden class=anchor aria-hidden=true href=#redirecting-stdout-and-stderr-to-same-file>#</a></h3><ul><li>Redirect stdout to file, stderr to stdout:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tail -n2 /etc/passwd /etc/shadow &gt; output_errors.txt 2&gt;&amp;<span style=color:#bd93f9>1</span>
</span></span></code></pre></div><ul><li>Explanation:<ul><li><code>2>&amp;1</code> → redirect stderr (2) to wherever stdout (1) is going.</li><li>Ampersand (<code>&</code>) indicates <strong>stream reference</strong>, not a filename.</li><li>Without <code>&</code>, it would create a file literally called <code>1</code>.</li></ul></li></ul><h3 id=redirections-with-pipes>Redirections with Pipes<a hidden class=anchor aria-hidden=true href=#redirections-with-pipes>#</a></h3><ul><li>You can still combine with pipes (<code>|</code>).</li><li>Example: extract MAC address:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ifconfig | grep ether | cut -d<span style=color:#f1fa8c>&#34; &#34;</span> -f10 &gt; mac.txt
</span></span></code></pre></div><ul><li><code>cut -d " " -f10</code> → splits by space, picks 10th field (MAC address).</li></ul><h3 id=the-tee-command>The <code>tee</code> Command<a hidden class=anchor aria-hidden=true href=#the-tee-command>#</a></h3><ul><li>Problem: normal redirection saves to file but hides from terminal.</li><li><code>tee</code> solves this by <strong>splitting output</strong> (like a plumbing T-junction).</li></ul><p>Examples:</p><ol><li>Save and display:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ifconfig | grep ether | tee mac.txt
</span></span></code></pre></div><ul><li>Displays on screen + saves to <code>mac.txt</code>.</li></ul><ol start=2><li>Append mode:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>who | tee -a mac.txt
</span></span></code></pre></div><ol start=3><li>Save to multiple files:</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>uname -r | tee -a mac.txt kernel.txt
</span></span></code></pre></div><h3 id=key-points-1>Key Points<a hidden class=anchor aria-hidden=true href=#key-points-1>#</a></h3><ul><li><code>2></code> → redirect stderr.</li><li><code>></code> defaults to stdout (1).</li><li><code>2>&amp;1</code> → merge stderr into stdout.</li><li>Redirections work with pipes.</li><li><code>tee</code> → write to file(s) and screen simultaneously.</li></ul><h2 id=bash-redirection--pipe-cheat-sheet>Bash Redirection & Pipe Cheat Sheet<a hidden class=anchor aria-hidden=true href=#bash-redirection--pipe-cheat-sheet>#</a></h2><hr><table><thead><tr><th>Symbol / Command</th><th>Meaning</th><th>Example</th><th>Notes</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>Redirect stdin (input)</td><td><code>sort &lt; file.txt</code></td><td>Reads input from file instead of keyboard</td></tr><tr><td><code>></code></td><td>Redirect stdout (overwrite)</td><td><code>echo hello > out.txt</code></td><td>Creates or overwrites file</td></tr><tr><td><code>>></code></td><td>Redirect stdout (append)</td><td><code>echo hi >> out.txt</code></td><td>Adds to file, keeps existing content</td></tr><tr><td><code>2></code></td><td>Redirect stderr (overwrite)</td><td><code>ls /root 2> errors.txt</code></td><td>Errors go to file</td></tr><tr><td><code>2>></code></td><td>Redirect stderr (append)</td><td><code>ls /root 2>> errors.txt</code></td><td>Errors appended</td></tr><tr><td><code>&></code></td><td>Redirect both stdout + stderr</td><td><code>cmd &> all.txt</code></td><td>Equivalent to <code>> all.txt 2>&amp;1</code> (bash-specific)</td></tr><tr><td><code>2>&amp;1</code></td><td>Redirect stderr to stdout</td><td><code>ls /root > all.txt 2>&amp;1</code></td><td>Merge both into same file</td></tr><tr><td>`</td><td>` (pipe)</td><td>Send stdout of one cmd as stdin to another</td><td>`ls</td></tr><tr><td>`cmd 2>&amp;1</td><td>cmd2`</td><td>Pipe stdout+stderr to next command</td><td>`ls /root 2>&amp;1</td></tr><tr><td><code>tee</code></td><td>Split output → screen + file</td><td>`ls</td><td>tee list.txt`</td></tr><tr><td><code>tee -a</code></td><td>Append mode for tee</td><td>`ls</td><td>tee -a list.txt`</td></tr><tr><td><code>tee file1 file2</code></td><td>Write to multiple files</td><td>`ls</td><td>tee f1 f2`</td></tr></tbody></table><h3 id=-quick-notes>⚡ Quick Notes:<a hidden class=anchor aria-hidden=true href=#-quick-notes>#</a></h3><ul><li><strong>File Descriptors (FDs):</strong><ul><li><code>0</code> → stdin</li><li><code>1</code> → stdout</li><li><code>2</code> → stderr</li></ul></li><li>No spaces allowed between <strong>FD number and operator</strong>:<br>✅ <code>2> file.txt</code><br>❌ <code>2 > file.txt</code></li><li>Without number: <code>></code> = <code>1></code> (stdout).</li></ul><h2 id=detailed-example-step-by-step-how-bash-processes-this-command>Detailed Example, Step-By-Step, How Bash Processes This Command<a hidden class=anchor aria-hidden=true href=#detailed-example-step-by-step-how-bash-processes-this-command>#</a></h2><hr><p>Example command (from the video), written exactly:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls <span style=color:#8be9fd;font-style:italic>$HOME</span> &gt; <span style=color:#ff79c6>$(</span>date +%H_%M<span style=color:#ff79c6>)</span>.txt
</span></span></code></pre></div><h3 id=1-tokenization>1) Tokenization<a hidden class=anchor aria-hidden=true href=#1-tokenization>#</a></h3><ul><li><p>Shell looks for <strong>unquoted meta characters</strong> (space, tab, newline, and the special symbols), to split the input into tokens.</p></li><li><p>In this command there are two unquoted meta characters, space and <code>></code>.</p></li><li><p>Important: the space inside <code>$(date +%H_%M)</code> does <strong>not</strong> count, because it is inside a command substitution, so it is treated as part of a single token.</p></li><li><p>Tokens produced:</p><ol><li><code>ls</code></li><li><code>$HOME</code></li><li><code>></code></li><li><code>$(date +%H_%M).txt</code></li></ol></li><li><p>Classification, after tokenization:</p><ul><li><strong>Words</strong> (no unquoted meta chars): <code>ls</code>, <code>$HOME</code>, <code>$(date +%H_%M).txt</code></li><li><strong>Operator</strong> (contains an unquoted meta char): <code>></code></li></ul></li><li><p>Note: <code>$</code> is not a meta character, so <code>$HOME</code> remains a single word token.</p></li></ul><h3 id=2-command-identification>2) Command identification<a hidden class=anchor aria-hidden=true href=#2-command-identification>#</a></h3><ul><li>The shell identifies the command type, simple or compound.</li><li>This command is a <strong>simple command</strong>, because it does not start with a reserved word (if, while, for, etc).</li><li>A simple command is terminated by a control operator or the invisible newline at the end of the line. Here the newline (end of line) terminates the command.</li><li><code>></code> is a redirection operator, not a control operator, so it stays part of the same simple command.</li></ul><h3 id=3-expansions-performed-in-strict-order>3) Expansions (performed in strict order)<a hidden class=anchor aria-hidden=true href=#3-expansions-performed-in-strict-order>#</a></h3><p>Bash runs expansions in this order, only some apply here:</p><ol><li>Brace expansion</li><li>Tilde expansion</li><li>Parameter and variable expansion</li><li>Command substitution</li><li>Arithmetic expansion</li><li>Process substitution</li><li>Word splitting</li><li>Filename expansion (globbing)</li></ol><ul><li>In our example, the relevant expansions are:<ul><li><strong>Parameter expansion</strong>: <code>$HOME</code> → <code>/home/student</code> (example value)</li><li><strong>Command substitution</strong>: <code>$(date +%H_%M)</code> → <code>11_16</code> (example output, hour_minute)</li></ul></li><li>After those expansions, the command becomes:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ls /home/student &gt; 11_16.txt
</span></span></code></pre></div><h3 id=4-word-splitting-and-filename-expansion-then-quote-removal>4) Word splitting and filename expansion, then quote removal<a hidden class=anchor aria-hidden=true href=#4-word-splitting-and-filename-expansion-then-quote-removal>#</a></h3><ul><li><strong>Word splitting</strong>: bash will split expansion results into words based on <code>$IFS</code> (by default space, tab, newline), but only for expansions not inside double quotes.<ul><li>In this example, neither expansion produced spaces, so <strong>no splitting</strong> occurs.</li></ul></li><li><strong>Filename expansion (globbing)</strong>: only happens if there are unquoted wildcard characters (<code>* ? [ ]</code>) in the words, none here.</li><li><strong>Quote removal</strong>: any remaining unquoted backslashes, single quotes, double quotes that were not produced by expansions are removed. There are none here, so nothing is removed.</li></ul><h3 id=5-redirections>5) Redirections<a hidden class=anchor aria-hidden=true href=#5-redirections>#</a></h3><ul><li>Shell inspects redirection operators and sets up file descriptors before executing the command.</li><li>Here the single greater-than <code>></code> is present, so:<ul><li>stdout (fd 1) is redirected to the file <code>11_16.txt</code>.</li><li>If <code>11_16.txt</code> does not exist, bash creates it.</li><li>If it exists, bash <strong>overwrites</strong> it (use <code>>></code> to append instead).</li></ul></li><li>After setting up the redirection, the command is ready to run.</li></ul><h3 id=execution>Execution<a hidden class=anchor aria-hidden=true href=#execution>#</a></h3><ul><li>Bash executes <code>ls</code> with argument <code>/home/student</code>.</li><li>The <code>ls</code> output goes to the file <code>11_16.txt</code> (because stdout was redirected).</li><li>Bash waits for the command to finish, then collects its exit status.</li></ul><h3 id=quick-checklist-with-the-most-important-rules-illustrated-by-this-example>Quick checklist, with the most important rules illustrated by this example<a hidden class=anchor aria-hidden=true href=#quick-checklist-with-the-most-important-rules-illustrated-by-this-example>#</a></h3><ul><li>Meta characters only act when <strong>unquoted</strong> (spaces inside <code>$(...)</code> are ignored for tokenization).</li><li><code>$</code> is not a meta character, it is part of words until parameter expansion runs.</li><li>Command substitution is treated as a single token during tokenization.</li><li>Expansions occur in a fixed order, parameter and command substitution happen before word splitting.</li><li>Word splitting uses <code>$IFS</code>, default is space, tab, newline. If an expansion yields spaces, it can produce extra words.</li><li><code>></code> is a redirection operator, not a control operator, so it does not split the command into multiple commands.</li><li>Redirections are applied after expansions and quote removal, before execution. <code>></code> creates or overwrites, <code>>></code> appends.</li><li>Invisible newline at end of input acts as the terminating control operator for a simple command.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/tech/>Tech</a></li><li><a href=http://localhost:1313/tags/shell/>Shell</a></li><li><a href=http://localhost:1313/tags/scripting/>Scripting</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/shell-expansion/><span class=title>« Prev</span><br><span>Shell Expansion in Shell Scripting</span>
</a><a class=next href=http://localhost:1313/posts/variable-in-shell-scripting/><span class=title>Next »</span><br><span>Variables in Shell Scripting</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on x" href="https://x.com/intent/tweet/?text=Shell%20Operation%20in%20Shell%20Scripting&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f&amp;hashtags=tech%2cshell%2cscripting"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f&amp;title=Shell%20Operation%20in%20Shell%20Scripting&amp;summary=Shell%20Operation%20in%20Shell%20Scripting&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f&title=Shell%20Operation%20in%20Shell%20Scripting"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on whatsapp" href="https://api.whatsapp.com/send?text=Shell%20Operation%20in%20Shell%20Scripting%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on telegram" href="https://telegram.me/share/url?text=Shell%20Operation%20in%20Shell%20Scripting&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Shell Operation in Shell Scripting on ycombinator" href="https://news.ycombinator.com/submitlink?t=Shell%20Operation%20in%20Shell%20Scripting&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fshell-operation-shell-scripting%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 </span>·
Made with ❤️ by <a href=http://localhost:1313/>Ahmad Hassan</a></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function s(){t.innerHTML="✓ Copied!",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>